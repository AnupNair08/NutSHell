
























	
	
	
	
		
		
		
		
		
		
			
			
					}
					}
					}
				}
				}
				}
				}
				}
			}
			}
			}
			}
			}
			}
			}
			}
			}
			}
			}
		// 		}
		// 	}
		// 	}
		// }
		// }
		// }
		// }
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
	//			       |
	//		    |
	// }
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
 * 
 * 
 * 
 * 
 * 
 * 
 */
 */
 */
 */
 */
 */
/**
/**
/**
/**
/**
/**
///
///
///
/// 
}
}
}
}
}
}
}
}
}
}
}
			addJob(jobs,pid,cl,BACKGROUND);
			addJob(jobs,pid,cl,FOREGROUND);
			arg[0] = l->cmd;
		arg[0] = p->cmd;
		arg[0] = p->cmd;
			arg[0] = right->cmd;
				arg[i+1] = l->args[i];
			arg[i+1] = p->args[i];
			arg[i+1] = p->args[i];
				arg[i+1] = right->args[i];
			arg[l->size + 1] = 0;
		arg[p->size + 1] = 0;
		arg[p->size + 1] = 0;
			arg[right->size + 1] = 0;
		// Bad input handler
		// 				break;
		// 				break;
		// 				break;
		// 				break;
///  @brief Function that generates the prompt to be displayed on the shell
 * @brief Function to execute a single command 
/// @brief Function to run the shell loop that forks new processes and invokes the exec system call to execute commands
/// @brief Global pointer to store the current working directory
 * @brief Initialises the shell and makes it run as foreground process.
/// @brief List to store the jobs for processing bg and fg operations
 * @brief Runs commands that have redirection of I/O
 * @brief Runs piped commands
 * @brief Signal handler to set completed background process status as done.
 * @brief Utility function to print colored text on terminal
		// 	// buf = handleArrowUp(h);
		// 	buf = pop(s);
		// 			case '<':
		// 			case '>':
		// 			case '|':
			char *arg[l->size + 2];
		char *arg[p->size + 2];
		char *arg[p->size + 2];
			char *arg[right->size + 2];
		char *buf;
	char buf[10];
					char *buf = (char *)malloc(sizeof(char)*s.st_size);
	char *cmd = (char *)malloc(sizeof(char) * CMD_SIZE);
char *cwd;
	char *term = (char *)malloc(128);
	//child 1
		//child of child 1
					close(fd);				
			close(fd);
		close(fd);
			close(fd2);
					close(hist);
			close(pidfd[0]);
			close(pidfd[0]);
		close(pidfd[0]);
			close(pidfd[1]);
			close(pidfd[1]);
		close(pidfd[1]);
		// 	cmd = buf;
		cmdList *cl = getParsed(strtok(cmd,"\n"));
	cmdList *parsedCmd;
		command *temp = &(parsedCmd->commandList[0]);
				continue;
			continue;
			continue;
			continue;	
		// 		continue;
		// 	continue;
    ctermid(term);
						cwd = newPrompt.wd;
	cwd = p.wd;
		// 			default:
#define BLUE "\x1B[34m"
#define CMD_SIZE 128
#define MAX_SIZE 128
#define RED "\033[1;31m"
#define RESET "\033[0m"
	// doubleStack* h = readHistory();
			dup2(fd,0);
			dup2(fd,0);
			dup2(fd,1);
			dup2(fd2,1);
			dup2(pidfd[0],0);
			dup2(pidfd[1],1);
					else{
			else{
		// else {
		// else{
		else{
		else{
	else{
	else{
	else{
		else if(fd != -1 && strcmp(type, "in") == 0){
				else if (strcmp(temp->cmd,"cd") == 0) {
				else if (strcmp(temp->cmd,"help") == 0) {
				else if (strcmp(temp->cmd,"history") == 0){
				else if (strcmp(temp->cmd,"jobs") == 0){
			else if(WIFCONTINUED(status)){
			else if (WIFEXITED(status)){
		//executes prog1
					exit(0);
				exit(-1);
				exit(-1);
			exit(-1);
			exit(-1);
		exit(-1);
		exit(-1);
		exit(1);
		exit(1);
		fd = open(fileName, O_CREAT | O_RDWR);
		fd = open(fileName, O_RDONLY);
    fd = open(term,O_RDONLY);
		fgets(cmd,MAX_SIZE,stdin);
		// 	for(int i = 0 ; i < cl->spcSize ; i++){
			for(int i = 0 ; i < l->size ; i++){
		for(int i = 0 ; i < p->size ; i++){
		for(int i = 0 ; i < p->size ; i++){
			for(int i = 0 ; i < right->size ; i++){
	for(int i = 0 ; i < size; i++){
		// 		fprintf(stderr,"No history stored\n");
			fprintf(stderr,"Parse error: Unexpected syntax\n");
					free(buf);
					freeJobs(jobs);
	getcwd(p.wd,MAX_SIZE);
	// Get default terminal
	gethostname(p.hostname,MAX_SIZE);
 *  	  Gets process id of the shell and sets the process group id equal to it
		// Get the child's process id and make it the group leader if there is none
	// Get the process id of the shell's main process
 * 		  Gives the control of the terminal to the process group id  
		// Handle only single command with arguments
	// hist = open(".sh_hist", O_CREAT | O_APPEND | O_RDWR);
		// History WIP	
		// 	if(buf == NULL || strcmp(buf,"") == 0){
					if (chdir(temp->args[0]) == 0){
		// if (cl->commandSize == 1){
		if(cl->tokenSize != cl->spcSize + 1){
		if(cmd == NULL || strcmp(cmd,"\n") == 0 || strlen(cmd) == 0){
			if(execvp(l->cmd,arg) == -1){
		if(execvp(p->cmd,arg) == -1){
		if(execvp(p->cmd,arg) == -1){
			if(execvp(right->cmd,arg) == -1){
			if(fd == -1){
	if(fd == -1){
		if(fd != -1 && strcmp(type,"out") == 0){
			if(fd2 == -1){
		if (getpgid(childpid) == 0){
	// if(hist == -1){
		if(parsedCmd == NULL){
	if(pid){
	if(pid < 0) {
	if(pid < 0) {
	if(pid == 0){
	if(pid == 0){  
	if(pid == 0){  
	if(pid == -1){
		if(pid2 == 0){
		if(p->infile){
		if (p->isBackground){
		if(!p->isBackground){
		if(p->outfile){
	if(r < 0){
		// if(strcmp(cmd,"!!\n") == 0){
				if (strcmp(temp->cmd,"exit") == 0) {
					if(temp->args[0] == NULL){
		if(temp->isBuiltin){
	if(type == "out"){
			if (WIFEXITED(status)){
			if(WIFSTOPPED(status)){
	// Ignore signals on the foreground processes  
#include<errno.h>
#include<fcntl.h>
#include "shell.h"
#include<signal.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<sys/stat.h>
#include<sys/wait.h>
#include<unistd.h>
			// Including this exit cleanly exits out of a process that ended up in an error, thus not causing the exit loops
	initShell();
		int childpid = getpid();
		// 	int fd;
	int fd;
int fd;
			int fd2 = open(p->outfile, O_CREAT | O_RDWR);
			int fd = open(p->infile, O_RDONLY);
					int fd = open(".sh_hist", O_RDONLY);
int hist;
int main(int argc, char *argv[]){
	int pid;
		int pid2 = fork();
	int pidfd[2];
	int pid = fork();
	int pid = fork();
	int r=pipe(pidfd);
	int shellpid = getpid();
	int size = jobs->commandSize;
		int status;
	int status;
jobList *jobs;
	jobs = initJobList();
 * @param cl Pointer to the command list
 * @param cwd Current working directory
 * @param fileName Name of the file to be used as I/O
 * @param hostname Hostname of the system
 * @param l Pointer to the left command
 * @param name Username of the system
 * @param p Pointer to command to be executed 
/// @param p Prompt structure to be printed on the terminal
 * @param right Pointer to the right command
 * @param type String denoting the type of redirection
	/*parent closes the read end and child closes the write end*/
		//parent of child 2 i.e child 1 executes prog2
	//	parent --> prog1 --> prog2
	/*parent writes to fd1 and child reads from fd0*/
		parsedCmd = cl;
		// 	parsedCmd = &(cl->commandList[0]);
		parsedCmd = NULL;
						perror("");
				perror("");
				perror("");
				perror("");
				perror("");
			perror("");
			perror("");
		perror("");
		perror("");
		perror("");
		perror("");
		perror("");
	// 	perror("History feature startup failed\n");
	p.hostname = (char *)malloc(sizeof(char) * MAX_SIZE);
	pid_t childpid = waitpid(getpid(),&status,WNOHANG);
	pid_t pid = fork();
			pid_t ppid = waitpid(pid,&status, WNOHANG);
			pid_t ppid = waitpid(pid,&status,WUNTRACED|WCONTINUED);
			p->isBackground = 0;
		// printCommand(&(jobs->commandList[i]));
	printf(BLUE"%s",p.wd);
		// printf("%d %d",cl->commandSize, cl->spcSize);
					printf("Help from the shell\n");
				//	printf("I will be Bourne Again.\n");
	// printf("parent alerted %d\n",childpid);
	printf(RED"%s@", p.uname);
	printf(RESET"$ ");
					printf("%s", buf);
		// 	// printf("%s", cmd);
					printf("Shell History:\n");
	printf("%s:", p.hostname);
	printf("Stopped");
	printf("Welcome to Dead Never SHell(DNSh).\n");
			// printJobID(jobs, pid);
		// 	printPrompt(p);
	  	printPrompt(p);
	// prog 1 | prog2
	// prog1 writes to stdout which can be linked to a pipefd1
	// prog2 reads from stdin which can be linked tp pipefd0
prompt getPrompt(){
						prompt newPrompt = getPrompt();
	prompt p;
	prompt p = getPrompt();
	p.uname = (char *)malloc(sizeof(char) * MAX_SIZE);
	p.uname = getenv("USER");
		// 	push(s,cmd);
			// puts(p->outfile);
	p.wd = (char *)malloc(sizeof(char) * MAX_SIZE);
		p.wd = cwd;
					read(fd,buf,s.st_size);
	//			       --> read its inp from stdin fd[0]
				return;
				return;
		return;
	return;
	return;
	return;
	return;
	return;
	return;
	return;
	return;
	return 0;
	return p;
///  @return Structure that contains the username and the current working directory
		// Run background processes with WNOHANG as it does not wait for the child process to exit
		runCmd(&(jobs->commandList[i]), jobs);
		runJob(parsedCmd);
		// 				runPipe(&(cl->commandList[i]),&(cl->commandList[i+1]));
		// 				runRedirCmd(&(cl->commandList[i]),cl->commandList[i+1].cmd,"in");
		// 				runRedirCmd(&(cl->commandList[i]),cl->commandList[i + 1].cmd,"out");
			setpgid(childpid,childpid);
	setpgid(shellpid, shellpid);
	setStatus(jobs,childpid,4);
				setStatus(jobs,pid,CONTINUE);
				setStatus(jobs,pid,DONE);
				setStatus(jobs,pid,DONE);
				setStatus(jobs,pid,DONE);
				setStatus(jobs,pid,STOPPED);
	// Set the shell process as the group leader
	signal (SIGCHLD, handleChild);
	signal(SIGCHLD, handleChild);
			signal (SIGCHLD, SIG_DFL);
			signal (SIGINT, SIG_DFL);
	signal (SIGINT, SIG_IGN);
			signal (SIGTSTP, SIG_DFL);
	signal (SIGTSTP, SIG_IGN);
			// signal (SIGTTOU, SIG_DFL);	
			signal (SIGTTOU, SIG_DFL);
	signal (SIGTTOU, SIG_IGN);
	stack *s = stackInit();
	startShell(p, s);
					stat(".sh_hist",&s);
					struct stat s;
		// 		switch(cl->spcOps[i]){
		// Takes signals from the terminal if it is a foreground process
			tcsetpgrp(fd,getpgid(childpid));
	tcsetpgrp(fd,shellpid);
						temp->args[0] = (char *)malloc(128);
						temp->args[0] = getenv("HOME");
	// Transfer the control to the shell
void handleChild(){
void handleStop(){
void initShell(){
void printPrompt(prompt p){
void runCmd(command *p, cmdList *cl){
void runJob(cmdList *jobs){
void runPipe(command *l, command *right){
void runRedirCmd(command *p, char *fileName, char *type){
void startShell(prompt p, stack *s){
			wait(NULL);
		wait(NULL);
		wait(NULL);
	//we have a pipe made such that fd[1] stdout --- stdin fd[0]
	while(1){
		// 	write(hist,cmd,strlen(cmd));
	//		    -> writes its op to stdout fd[1]
